"""PokeTrade2 Models

Since PokeTrade2 is already used as the application management folder,
we have to use a separate folder. "Trading" sounded the best.
"""

__all__ = ["TradingPolicy", "Pokemon", "Ability", "Attack"]
__author__ = "Advaith Menon"

from django.db import models

from accounts.models import User


class TradingPolicy(object):
    """Represents the trading policy of a pokemon.

    A pokemon can be FOR_SALE, and any user could buy it for its
    ``Pokemon.sell_price``. However, if it is not for sale (i.e.
    it has an owner, it is CLAIMED. If a Pokemon does not have a
    nonzero sell price and no owner, it'll be
    RESERVED_FOR_NEW_USERS.

    This class is intentionally not an enum, to simplify templating.
    """
    # do not change these values!
    FOR_SALE = 1
    CLAIMED = 2
    RESERVED_FOR_NEW_USERS = 3


class Pokemon(models.Model):
    """Represents a singular Pokemon."""
    # ID is automatically taken care of by Django

    # If there is no code below, run the code generator!!
    # Rarity Enum
    # ~machine~begin~{e77bdfa3-a871-445c-b412-d7914751c6b7}
    # This is machine-generated code.
    # DO NOT EDIT IT BY HAND. 
    # To update code from TCG API, run: 
    #     python3 manage.py generatecode
    #
    # Code generated by FieldEditor (embedded), version 0.1.0
    # Copyright (c) 2025-present Advaith Menon
    # All rights reserved.
    # Rarities (generated from TCG) 
    class Rarity(models.TextChoices):
        ACE_SPEC_RARE = 'ACE_SPEC_RARE', 'ACE SPEC Rare';
        AMAZING_RARE = 'AMAZING_RARE', 'Amazing Rare';
        CLASSIC_COLLECTION = 'CLASSIC_COLLECTION', 'Classic Collection';
        COMMON = 'COMMON', 'Common';
        DOUBLE_RARE = 'DOUBLE_RARE', 'Double Rare';
        HYPER_RARE = 'HYPER_RARE', 'Hyper Rare';
        ILLUSTRATION_RARE = 'ILLUSTRATION_RARE', 'Illustration Rare';
        LEGEND = 'LEGEND', 'LEGEND';
        PROMO = 'PROMO', 'Promo';
        RADIANT_RARE = 'RADIANT_RARE', 'Radiant Rare';
        RARE = 'RARE', 'Rare';
        RARE_ACE = 'RARE_ACE', 'Rare ACE';
        RARE_BREAK = 'RARE_BREAK', 'Rare BREAK';
        RARE_HOLO = 'RARE_HOLO', 'Rare Holo';
        RARE_HOLO_EX = 'RARE_HOLO_EX', 'Rare Holo EX';
        RARE_HOLO_GX = 'RARE_HOLO_GX', 'Rare Holo GX';
        RARE_HOLO_LV_X = 'RARE_HOLO_LV_X', 'Rare Holo LV.X';
        RARE_HOLO_STAR = 'RARE_HOLO_STAR', 'Rare Holo Star';
        RARE_HOLO_V = 'RARE_HOLO_V', 'Rare Holo V';
        RARE_HOLO_VMAX = 'RARE_HOLO_VMAX', 'Rare Holo VMAX';
        RARE_HOLO_VSTAR = 'RARE_HOLO_VSTAR', 'Rare Holo VSTAR';
        RARE_PRIME = 'RARE_PRIME', 'Rare Prime';
        RARE_PRISM_STAR = 'RARE_PRISM_STAR', 'Rare Prism Star';
        RARE_RAINBOW = 'RARE_RAINBOW', 'Rare Rainbow';
        RARE_SECRET = 'RARE_SECRET', 'Rare Secret';
        RARE_SHINING = 'RARE_SHINING', 'Rare Shining';
        RARE_SHINY = 'RARE_SHINY', 'Rare Shiny';
        RARE_SHINY_GX = 'RARE_SHINY_GX', 'Rare Shiny GX';
        RARE_ULTRA = 'RARE_ULTRA', 'Rare Ultra';
        SHINY_RARE = 'SHINY_RARE', 'Shiny Rare';
        SHINY_ULTRA_RARE = 'SHINY_ULTRA_RARE', 'Shiny Ultra Rare';
        SPECIAL_ILLUSTRATION_RARE = 'SPECIAL_ILLUSTRATION_RARE', 'Special Illustration Rare';
        TRAINER_GALLERY_RARE_HOLO = 'TRAINER_GALLERY_RARE_HOLO', 'Trainer Gallery Rare Holo';
        ULTRA_RARE = 'ULTRA_RARE', 'Ultra Rare';
        UNCOMMON = 'UNCOMMON', 'Uncommon';
    
    
    # ~machine~end~{e77bdfa3-a871-445c-b412-d7914751c6b7}

    # ID in the TCG database
    tcg_id = models.CharField(max_length=256, null=True, blank=True,
                              default=None, unique=True)
    name = models.CharField(max_length=256)
    supertype = models.CharField(max_length=256, null=True, blank=True)
    # NOTE: use the property ".subtypes", it is a list which will
    # do the serialization for you.
    subtype_l = models.TextField(default="");
    hp = models.IntegerField(default=-1);
    # NOTE: use the property ".types", it is a list which will
    # do the serialization for you.
    type_l = models.TextField(default="");
    # description = models.TextField(default="")
    # Some pokemon don't evolve from anything. Just like how some random
    # bacteria pop out of nowhere.
    # evolvesFrom = models.CharField(max_length=127, null=True,
    # blank=True)
    # evolves_from = models.ForeignKey("self", on_delete=models.CASCADE,
    #                                 null=True, blank=True);
    evolves_from = models.CharField(max_length=256, null=True, blank=True,
                                    default=None)
    # Sometimes, Pokemon just evolve to nothing. Just as how after
    # robots take over the world, there will be nothing left. Just
    # better robots.
    # evolvesTo = models.CharField(max_length=127, null=True, blank=True)
    # NOTE: we don't need evolvesTo, we can just query for all
    # "children" of a pokemon since evolvesFrom is a PK.

    # separated by newlines
    rules = models.TextField(default="", blank=True);

    # To get abilities, refer to the docs:
    # https://docs.djangoproject.com/en/5.1/topics/db/queries/#following-relationships-backward

    # NOTE: use the property ".weaknesses", it is a hashmap which will
    # do the serialization for you.
    weakness_h = models.TextField(default="", blank=True);

    # NOTE: use the property ".resistances", it is a hashmap which will
    # do the serialization for you.
    resistance_h = models.TextField(default="", blank=True);

    # NOTE: use the property ".retreat_cost", it is a list which will
    # do the serialization for you.
    retreat_l = models.TextField(default="", blank=True);

    # NOTE: use the virtual property ".converted_retreat_cost"
    # (non-editable)

    # NOTE: set has been skipped with prior discussion with Hardik

    # NOTE: field name is misleading
    number = models.CharField(max_length=64, default="", blank=True);

    artist = models.CharField(max_length=256, default="", blank=True);



    flavorText = models.TextField(default="", blank=True);

    # NOTE: use the property ".national_pokedex_numbers" instead, it is
    # a list which will do the serialization for you.
    national_l = models.TextField(default="", blank=True);

    # If there is no code below, run the code generator!!
    # Rarity Field
    # ~machine~begin~{028c3792-35e5-4337-8947-67c7f0a8f139}
    # This is machine-generated code.
    # DO NOT EDIT IT BY HAND. 
    # To update code from TCG API, run: 
    #     python3 manage.py generatecode
    #
    # Code generated by FieldEditor (embedded), version 0.1.0
    # Copyright (c) 2025-present Advaith Menon
    # All rights reserved.
    # Raritity Field 
    # Machine-generated due to unknown max_length
    rarity = models.CharField(
        max_length=25,
        choices=Rarity,
        default=Rarity.UNCOMMON);
    
    # ~machine~end~{028c3792-35e5-4337-8947-67c7f0a8f139}

    flavorText = models.TextField(default="", blank=True);

    image = models.ImageField(upload_to='pokemon_images/')
    card = models.ImageField(upload_to='pokemon_card/', null=True,
                             blank=True)

    # NOTE: 0 is a null value for this
    average_sell_price = models.FloatField(default=0);
    low_price = models.FloatField(default=0);
    trend_price = models.FloatField(default=0);
    suggested_price = models.FloatField(default=0);

    # real sell price
    sell_price = models.FloatField(default=0);

    # cost price
    cost_price = models.FloatField(default=0);

    # owner of Pokemon
    # The pokemon subreddit says that Pokemon is Pocket Monsters
    # So pokemons is the plural of Pokemon
    # https://www.reddit.com/r/pokemon/comments/1wu6kr/
    # games_why_isnt_pokemons_the_plural_of_pokemon/
    owner = models.ForeignKey(User, on_delete=models.SET_NULL,
                              null=True, blank=True,
                              related_name="pokemons")

    wishers = models.ManyToManyField(User,
                                     related_name="wishlist")

    def __str__(self):
        return self.name

    @property
    def weaknesses(self):
        """A Pythonic Getter for weaknesses.

        :return: The weaknesses of a Pokemon
        :rtype: dict
        """
        return {
                x.partition("=")[0] : x.partition("=")[2]
                for x in self.weakness_h.split(";")
               }

    @weaknesses.setter
    def weaknesses(self, weaknesses):
        """A Pythonic way to set weaknesses.

        :param weaknesses: The weaknesses to set to.
        :type weaknesses: dict
        """
        if weaknesses is None:
            weaknesses = dict(); # an empty dict works
        retstr = "";
        for k, v in weaknesses.items():
            retstr += "%s=%s;" % (k, v);
        retstr = retstr.strip(";");
        self.weakness_h = retstr;

    @property
    def resistances(self):
        """A Pythonic Getter for resistances.

        :return: The resistances of a Pokemon
        :rtype: dict
        """
        return {
                x.partition("=")[0] : x.partition("=")[2]
                for x in self.resistance_h.split(";")
               }

    @resistances.setter
    def resistances(self, resistances):
        """A Pythonic way to set resistances.

        :param resistances: The resistances to set to.
        :type resistances: dict
        """
        if resistances is None:
            resistances = dict(); # an empty dict works
        retstr = "";
        for k, v in resistances.items():
            retstr += "%s=%s;" % (k, v);
        retstr = retstr.strip(";");
        self.resistance_h = retstr;

    @property
    def retreat_cost(self):
        """A Pythonic way to deal with retreats.

        :return: A retreat cost, in the form of a list
        :rtype: list
        """
        return self.retreat_l.split(",");

    @retreat_cost.setter
    def retreat_cost(self, retreat_cost):
        """A Pythonic way to set retreats.

        :param retreat_cost: The retreat cost, in the form of a list
        :type retreat_cost: list
        """
        self.retreat_l = ",".join(retreat_cost);

    @property
    def converted_retreat_cost(self):
        """Return the number of retreat costs.

        :return: The number of retreat costs, or 0 if not applicable
        :rtype: int
        """
        return self.retreat_l.count(",") + 1 \
                if self.retreat_l is not None else 0;

    @property
    def subtypes(self):
        """A Pythonic way to deal with subtypes.

        :return: A subtype, in the form of a list
        :rtype: list
        """
        return self.subtype_l.split(",");

    @subtypes.setter
    def subtypes(self, subtypes):
        """A Pythonic way to set subtypes.

        :param subtypes: The subtype, in the form of a list
        :type subtypes: list
        """
        self.subtype_l = ",".join(subtypes);

    @property
    def types(self):
        """A Pythonic way to deal with types.

        :return: A type, in the form of a list
        :rtype: list
        """
        return self.type_l.split(",");

    @types.setter
    def types(self, types):
        """A Pythonic way to set types.

        :param types: The type, in the form of a list
        :type types: list
        """
        self.type_l = ",".join(types);


    @property
    def trading_policy(self):
        """Get the trading policy of this user.

        :return: The trading policy of the user, as defined by the
            corresponding Enum.
        :rtype: class`TradingPolicy`
        """
        if self.sell_price > 0:
            # if it has no user the money goes into the blackhole
            # you will probably see Cooper out there w/ the bookshelves
            return TradingPolicy.FOR_SALE
        elif self.owner is not None:
            return TradingPolicy.CLAIMED
        else:
            return TradingPolicy.RESERVED_FOR_NEW_USERS

    def __repr__(self):
        return "<Pokemon id=%s, name=%s>" % (self.pk, self.name);


class Ability(models.Model):
    """Represents the abilities of a Pokemon.
    """
    name = models.CharField(max_length=128);
    # description of the ability
    text = models.TextField();
    type = models.CharField(max_length=256);
    pokemons = models.ManyToManyField(Pokemon);
    class Meta:
        constraints = [
                models.UniqueConstraint(fields=["name"],
                                        name="uniq_ability_name"),
                ];
        indexes = [
                models.Index(fields=["name"], name="ix_ability_name"),
                ];

    def __repr__(self):
        return "<Ability id=%s, name=%s>" % (self.pk, self.name);


class Attack(models.Model):
    """Represents the attacks of a Pokemon.
    """
    name = models.CharField(max_length=128);
    # For now, costs are a text field with ',' as delimiter
    cost_s = models.TextField();
    text = models.TextField();
    damage = models.CharField(max_length=64);
    # this is a many-to-one since the value of damage could vary.
    pokemons = models.ForeignKey(Pokemon, on_delete=models.CASCADE);

    @property
    def costs(self):
        """Get the value of costs in a Pythonic way.

        :return: The costs of the attack
        :rtype: list
        """
        return self.cost_s.split(",");

    @costs.setter
    def costs(self, costs):
        """Set the value of costs in a Pythonic way.

        :param costs: The costs list to set to.
        :type costs: list
        """
        self.cost_s = ",".join(costs);

    class Meta:
        constraints = [
                models.UniqueConstraint(fields=["name"],
                                        name="uniq_attack_name"),
                ];
        indexes = [
                models.Index(fields=["name"], name="ix_attack_name"),
                ];


