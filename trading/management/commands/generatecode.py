#!/usr/bin/python3
# FieldEditor (embedded), version 0.1.0 dated 2025-04-08
# Copyright (c) Advaith Menon, 2025
# All rights reserved. No part of this file may be copied or distributed
# by any means, digital or otherwise.

from abc import ABC, abstractmethod
import collections
import glob
import logging
import re
import sys
import tempfile
from uuid import UUID

from django.core.management.base import BaseCommand
import pokemontcgsdk as pts


logger = logging.getLogger(__name__);


__version__ = "0.1.0";
__author__ = "Advaith Menon";


# Prefix for any machine-generated code.
PREFIX = (
    "# This is machine-generated code.\n"
    "# DO NOT EDIT IT BY HAND. \n"
    "# To update code from TCG API, run: \n"
    "#     python3 manage.py generatecode\n"
    "#\n"
    f"# Code generated by FieldEditor (embedded), version {__version__}\n"
    f"# Copyright (c) 2025-present {__author__}\n"
    "# All rights reserved.\n"
);

# Regex match for a machine identifier.
MACHINE_IDENTIFIER = \
        re.compile(r"([ \t]*)# ~machine~begin~\{([0-9a-f-]+)\}");
MACHINE_END = \
        re.compile(r"([ \t]*)# ~machine~end~\{([0-9a-f-]+)\}");


def to_ident(val):
    """Convert any string to an identifier.

    :param val: The source string to convert.
    :type val: str
    :return: The converted string
    :rtype: str
    """
    return re.sub(r"[^a-zA-Z0-9_]+", '_', val).upper();


def str_pers_hash(val):
    """Hash a string to a (hopefully) unique and fixed value.
    """
    o = 0
    for c in val:
        o *= 256
        o += ord(c);
    return o;
# A MachineBegin object
MachineBegin = collections.namedtuple("MachineBegin",
                                      ("loc", "uuid", "indentation"));

class MachineApplier(ABC):
    @abstractmethod
    def execute(self):
        """Executes a Machine Applier.

        :return: String (w/o indentation) of the enum.
        :rtype: str
        """
        pass

    @property
    @abstractmethod
    def __uuid__(self):
        """Property containing the UUID of the class.

        :return: A unique identifier of the class.
        :rtype: class`uuid.UUID`
        """
        pass

    def __repr__(self):
        return "<%s {%s}>" % (self.__class__.__name__, self.__uuid__);


class TypeApplier(MachineApplier):
    __uuid__ = UUID("64d2e7a7-19d3-4b72-9f8e-c3e2719b0fe7");

    def execute(self):
        logger.info("Apply type applier");
        return "DEMO";


class SubtypeApplier(MachineApplier):
    __uuid__ = UUID("7c778c4a-0950-499f-88c6-d318bd6930f4");

    def execute(self):
        return "DEMO SUBTYPE";


class RarityApplier(MachineApplier):
    __uuid__ = UUID("e77bdfa3-a871-445c-b412-d7914751c6b7");

    def execute(self):
        stri = "# Rarities (generated from TCG) \n"
        stri += "class Rarity(models.TextChoices):\n"
        i = 0;
        for rarity in pts.Rarity.all():
            ident = to_ident(rarity);
            stri += "    %s = %s, %s;\n" % (ident, repr(ident), repr(rarity));
        stri += "\n";
        return stri;


class RarityFieldApplier(MachineApplier):
    __uuid__ = UUID("028c3792-35e5-4337-8947-67c7f0a8f139");

    def execute(self):
        stri = ("# Raritity Field \n"
                "# Machine-generated due to unknown max_length\n")
        stri += ("rarity = models.CharField(\n"
                 "    max_length=%d,\n"
                 "    choices=Rarity,\n"
                 "    default=Rarity.UNCOMMON);\n") % \
                         max(map(len, pts.Rarity.all()));
        return stri;


class DefaultApplier(MachineApplier):
    """A fallback applier to be used when the UUID is invalid.
    """
    __uuid__ = UUID("c8b6b640-23ab-4b4a-b78e-978338c0a0b6");

    def execute(self):
        return (
            "print(\"The applier with the given UUID was not found or was\"\n"
            "      \" the UUID of the DefaultApplier. Kindly update \"\n"
            "      \"your code to use a valid MachineApplier ID.\",\n"
            "      file=__import__(\"sys\").stderr);");


class PatternSearch(object):
    """Search for a Pattern."""
    def __init__(self):
        self.file = None
        self.ptr = -1
        self.wptr = -1
        self.current = None;

    def open(self, fil):
        with open(fil, "r") as fp:
            self.file = fp.read();
        self.ptr = 0;
        self.wptr = 0;

    def next_begin(self):
        """Find the next machine begin spot.

        :return: The location of the next machine begin spot, and its
            UUID.
        :rtype: class`MachineBegin`
        """
        if self.file is None:
            raise TypeError("file is null");

        reg = MACHINE_IDENTIFIER.search(self.file, self.ptr);
        if reg is None:
            self.ptr = len(self.file);
            self.current = None;
            return None;
        # don't match the same MID again
        self.ptr = reg.end(0);
        self.current = MachineBegin(loc=self.ptr, uuid=UUID(reg.group(2)),
                                    indentation=reg.group(1));
        return self.current;

    def next_end(self, readonly=False):
        """Seek to the next machine end spot.

        Internal pointers are updated as follows:
        #. ptr is updated to be the end of the line
        #. wptr is updated to the beginning of the line
        #. current is updated to None
        :param readonly: Do not modify any pointers if parameter is true.
        :type readonly: bool
        :return: The original data present in the Machine Block.
        :rtype: str
        """
        reg = MACHINE_END.search(self.file, self.ptr);
        if reg is None:
            raise TypeError("no matching end for begin");
        old_data = self.file[self.ptr:reg.start(0)];
        if readonly:
            return old_data;
        # start matching after the machine end
        self.ptr = reg.end(0);
        # start with the machine end
        self.wptr = reg.start(0);
        if self.current.uuid != UUID(reg.group(2)):
            raise TypeError("UUID of begin and end do not match");
        return old_data

    def write(self, fil, data=None):
        """Write new changes to an IO buffer for the current match.
        Writes can only be performed once.

        :param data: The text data to write. Indentation is not to be cared
            about.
        :type data: str
        :param fil: The IO buffer to write to.
        """
        # write first changes (until machine~begin or the end of file)
        fil.write(self.file[self.wptr:self.ptr] + "\n");

        # skip rest if Data is none or current is none
        if self.current is None or data is None:
            self.wptr = len(self.file);
            return

        for line in data.split("\n"):
            fil.write(self.current.indentation + line + "\n");

        # seek to machine end
        self.next_end();


def process(ps, appliers, file_name):
    """Process a file.

    :param ps: The PatternSearch object to reuse.
    :param appliers: A map of UUIDs to appliers.
    :type appliers: dict
    :param file_name: The name of the file to process.
    :type file_name: str
    """
    ps.open(file_name);
    f = tempfile.TemporaryFile("r+");
    x = ps.next_begin();
    found = False
    while x is not None:
        applier = appliers.get(x.uuid, DefaultApplier())
        found = True
        logger.info("Found applier: %s in %s", repr(applier), file_name);
        ps.write(f, PREFIX + applier.execute());
        x = ps.next_begin();
    ps.write(f);
    f.seek(0);
    if found:
        with open(file_name, "w") as fp:
            fp.write(f.read());
    f.close();


def main(argc, argv):
    logging.basicConfig(level=logging.INFO);
    patterns = [TypeApplier(), SubtypeApplier(), RarityApplier(),
                RarityFieldApplier()]
    uuidmap = {x.__uuid__ : x for x in patterns}

    logger.info("Following appliers will be used");
    for pattern in patterns:
        logger.info(repr(pattern));

    ps = PatternSearch();

    for pfile in glob.glob("**/*.py", recursive=True):
        if pfile.startswith("venv"):
            # this is a waste of time
            # like trying to change people
            # instead change yourself
            continue
        process(ps, uuidmap, pfile);

class Command(BaseCommand):
    help = "Executes FieldEditor (embedded)."

    def handle(self, *args, **options):
        main(len(args), args)

